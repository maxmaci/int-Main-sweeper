
/*std::map<Coord, int> bordo_conteggio;

for (int i = 0; i < partita._altezza(); i++)
{
	for (int j = 0; j < partita._larghezza(); j++)
	{
		if (partita._campo_visibile()[i][j] > 0 && partita.conta_non_scavati_vicini(i, j) > 0)
		{
			if (partita._campo_visibile().indici_leciti(i - 1, j - 1) && partita._campo_visibile()[i - 1][j - 1] == -3)	bordo_conteggio[Coord(i - 1, j - 1)]++;
			if (partita._campo_visibile().indici_leciti(i - 1, j) && partita._campo_visibile()[i - 1][j] == -3)		bordo_conteggio[Coord(i - 1, j)]++;
			if (partita._campo_visibile().indici_leciti(i - 1, j + 1) && partita._campo_visibile()[i - 1][j + 1] == -3)	bordo_conteggio[Coord(i - 1, j + 1)]++;
			if (partita._campo_visibile().indici_leciti(i, j - 1) && partita._campo_visibile()[i][j - 1] == -3)		bordo_conteggio[Coord(i, j - 1)]++;
			if (partita._campo_visibile().indici_leciti(i, j + 1) && partita._campo_visibile()[i][j + 1] == -3)		bordo_conteggio[Coord(i, j + 1)]++;
			if (partita._campo_visibile().indici_leciti(i + 1, j - 1) && partita._campo_visibile()[i + 1][j - 1] == -3)	bordo_conteggio[Coord(i + 1, j - 1)]++;
			if (partita._campo_visibile().indici_leciti(i + 1, j) && partita._campo_visibile()[i + 1][j] == -3)		bordo_conteggio[Coord(i + 1, j)]++;
			if (partita._campo_visibile().indici_leciti(i + 1, j + 1) && partita._campo_visibile()[i + 1][j + 1] == -3)	bordo_conteggio[Coord(i + 1, j + 1)]++;
		}
	}
}

std::vector<std::pair<Coord, int> > bordo_conteggio_vettore(bordo_conteggio.begin(), bordo_conteggio.end());

std::sort(bordo_conteggio_vettore.begin(), bordo_conteggio_vettore.end(), compara);

for (int i = 0; i < bordo_conteggio_vettore.size(); i++)
{
	std::cout << "\"" << bordo_conteggio_vettore[i].first.first << ", " << bordo_conteggio_vettore[i].first.second << "\": " << bordo_conteggio_vettore[i].second << std::endl;
}
*/

// TO DO: recuperare QUESTA SOTTO per qualche versione

/*	std::pair<std::vector<Coord>, std::vector<Coord>> numeri_e_incognite = estrai_celle_incognite();

if (numeri_e_incognite.first.size() != 0)
{
	std::vector<Coord> coordinate_numeri_bordo = numeri_e_incognite.first;
	std::vector<Coord> incognite_bordo = numeri_e_incognite.second;

	std::map<Coord, std::pair<double, double>> incognite_probabilita_minmax;

	for (int n = 0; n < incognite_bordo.size(); n++)
	{
		int i = incognite_bordo[n].first;
		int j = incognite_bordo[n].second;

		partita._campo_visibile()[i][j] - partita.conta_bandiere_vicine(i, j);

		std::vector<double> probabilita(0);

		if (trova_elemento(coordinate_numeri_bordo, Coord(i - 1, j - 1)))	probabilita.push_back(double(partita._campo_visibile()[i - 1][j - 1] - partita.conta_bandiere_vicine(i - 1, j - 1)) / double(partita.conta_non_scavati_vicini(i - 1, j - 1)) );
		if (trova_elemento(coordinate_numeri_bordo, Coord(i - 1, j)))		probabilita.push_back(double(partita._campo_visibile()[i - 1][j] - partita.conta_bandiere_vicine(i - 1, j)) / double(partita.conta_non_scavati_vicini(i - 1, j)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i - 1, j + 1)))	probabilita.push_back(double(partita._campo_visibile()[i - 1][j + 1] - partita.conta_bandiere_vicine(i - 1, j + 1)) / double(partita.conta_non_scavati_vicini(i - 1, j + 1)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i, j - 1)))		probabilita.push_back(double(partita._campo_visibile()[i][j - 1] - partita.conta_bandiere_vicine(i, j - 1)) / double(partita.conta_non_scavati_vicini(i, j - 1)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i, j + 1)))		probabilita.push_back(double(partita._campo_visibile()[i][j + 1] - partita.conta_bandiere_vicine(i, j + 1)) / double(partita.conta_non_scavati_vicini(i, j + 1)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i + 1, j - 1)))	probabilita.push_back(double(partita._campo_visibile()[i + 1][j - 1] - partita.conta_bandiere_vicine(i + 1, j - 1)) / double(partita.conta_non_scavati_vicini(i + 1, j - 1)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i + 1, j)))		probabilita.push_back(double(partita._campo_visibile()[i + 1][j] - partita.conta_bandiere_vicine(i + 1, j)) / double(partita.conta_non_scavati_vicini(i + 1, j)));
		if (trova_elemento(coordinate_numeri_bordo, Coord(i + 1, j + 1)))	probabilita.push_back(double(partita._campo_visibile()[i + 1][j + 1] - partita.conta_bandiere_vicine(i + 1, j + 1)) / double(partita.conta_non_scavati_vicini(i + 1, j + 1)));

		double probabilita_min = *std::min_element(probabilita.cbegin(), probabilita.cend());
		double probabilita_max = *std::max_element(probabilita.cbegin(), probabilita.cend());

		for (int k = 0; k < probabilita.size(); k++) std::cout << probabilita[k] << " ";
		std::cout << std::endl;

		incognite_probabilita_minmax[incognite_bordo[n]] = std::pair <double, double>(probabilita_min, probabilita_max);

	}

	for (std::map<Coord, std::pair<double, double> >::const_iterator it = incognite_probabilita_minmax.cbegin(); it != incognite_probabilita_minmax.cend(); it++)
	{
		std::cout << "(" << it->first.first << ", " << it->first.second << "): prob.min = " << it->second.first << ", prob.max = " << it->second.second << std::endl;
	}

	std::pair<Coord, std::pair<double, double> > incognite_probabilita_minmax_sort = *std::min_element(incognite_probabilita_minmax.cbegin(), incognite_probabilita_minmax.cend(), compara);
	incognite_probabilita_minmax_sort.first;
}
else
{

}
*/

/*
	Campo copia_campo = partita;

	std::map<int, std::vector<std::vector<bool> > > raccolta_disposizioni;

	std::vector<std::vector<Coord> > incognite_separate = separa_bordo();

	for (int i = 0; i < incognite_separate.size(); i++)
	{
		metodo_probabilistico_ricorsivo(copia_campo, raccolta_disposizioni, incognite_separate[i], 0);
	}

	for (std::map<int, std::vector<std::vector<bool> > >::iterator it = raccolta_disposizioni.begin(); it != raccolta_disposizioni.end(); it++)
	{
		for (int j = 0; j < (*it).second.size(); j++)
		{
			for (int k = 0; k < (*it).second[j].size(); k++)
			{
				std::cout << (*it).second[j][k];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl << std::endl;
	}
	*/

	// TO DO: eliminare
	// using recursion find all the mine configurations
	// that one section can possibly have
/*
void Risolutore::metodo_probabilistico_ricorsivo(Campo& copia_campo, std::map<int, std::vector<std::vector<bool> > >& raccolta_disposizioni,
	std::vector<Coord> bordo, int ramo)
{
	int totalMineNum = partita._mine();
	int flagCount = partita._numero_bandiere();
	int _col = partita._larghezza(), _row = partita._altezza();

	// total flagcount cannot exceed the total mineNum
	if (flagCount > totalMineNum) return;

	// if the flagcount is bigger than the neighborcount already?
	// then, return before it goes through more recursion.
	// for more optimization, the open tiles for the section can be
	// put into a container to be looped

	if (ramo != bordo.size()) {
		for (int i = 0; i < bordo.size(); i++)//auto& anyTile : section
		{
			int tileCol = bordo[i].second, tileRow = bordo[i].second;
			for (int yoff = -1; yoff <= 1; ++yoff)
			{
				for (int xoff = -1; xoff <= 1; ++xoff)
				{
					int c = tileCol + xoff;
					int r = tileRow + yoff;
					// within in the range
					if (c > -1 && c < _col &&
						r > -1 && r < _row)
					{
						// should be revealed
						if (!copia_campo._campo_visibile().is_elemento(r, c, -3))
						{
							// if the flagcount is bigger than the neighborcount already?
							// then, return before it goes through more recursion.
							if (copia_campo.conta_bandiere_vicine(c, r) > copia_campo._campo_visibile().conta_caselle_vicine(c, r))
								return;
						}
					}
				}
			}
		}
		int qCol = bordo[ramo].second;
		int qRow = bordo[ramo].first;
		copia_campo.gioca(qCol, qRow, 'B');		// guess set
		metodo_probabilistico_ricorsivo(copia_campo, raccolta_disposizioni, bordo, ramo + 1);
		copia_campo.gioca(qCol, qRow, 'B');		// guess unset
		metodo_probabilistico_ricorsivo(copia_campo, raccolta_disposizioni, bordo, ramo + 1);
	}
	// DFS Search
	// go to depth k and check it is correct
	else if (ramo == bordo.size())
	{
		for (int i = 0; i < bordo.size(); i++)//auto& anyTile : section
		{
			int tCol = bordo[i].second, tRow = bordo[i].second;
			for (int yoff = -1; yoff <= 1; ++yoff)
			{
				for (int xoff = -1; xoff <= 1; ++xoff)
				{
					int c = tCol + xoff, r = tRow + yoff;
					// within in the range
					if (c > -1 && c < _col &&
						r > -1 && r < _row)
					{
						// should be revealed
						if (!copia_campo._campo_visibile().is_elemento(r, c, -3))
						{
							// if the counting is not the same?
							// then it is not the possible answer.
							if (copia_campo.conta_bandiere_vicine(c, r) != copia_campo._campo_visibile().conta_caselle_vicine(c, r))
								return;
						}
					}
				}
			}
		}
		// when it is the end of the game and there isn't the same number of the flags
		// that totals to be the totalMineNum, then it is not a solution.
		if (copia_campo._numero_bandiere() != totalMineNum) // borderOptimization&&
			return;
		std::vector<bool> oneSectionSolution;	// store a one configuration
		int mineCountForSection = 0;
		for (int i = 0; i < bordo.size(); i++)
		{
			int tCol = bordo[i].second, tRow = bordo[i].first;
			bool flagged = copia_campo._campo_visibile().is_elemento(tRow, tCol, -3);
			oneSectionSolution.push_back(flagged);
			if (flagged) ++mineCountForSection;
		}
		std::map<int, std::vector<std::vector<bool> > >::iterator mineCountFound = raccolta_disposizioni.find(mineCountForSection);
		// if there isnt a vector for the mine count
		if (mineCountFound == raccolta_disposizioni.end())
		{
			std::vector<std::vector<bool> > vectorSectionSolution;
			vectorSectionSolution.push_back(oneSectionSolution);
			raccolta_disposizioni.insert(make_pair(mineCountForSection, vectorSectionSolution));
		}
		// if there is
		else
		{
			mineCountFound->second.push_back(oneSectionSolution);
		}
		return;
	}
}
*/


/*
void Risolutore::metodo_probabilistico_ricorsivo(std::vector<Matrice<bool> > disposizioni, const std::vector<Coord>& bordo, int k)
{
		// Return if at this point, it's already inconsistent
	for (int i = 0; i < partita._altezza(); i++)
	{
		for (int j = 0; j < partita._larghezza(); j++)
		{

			std::cout << "Ciao: " << i + 1 << ", " << j + 1 << std::endl;
			// Count flags for endgame cases
			int currentBlockValue = partita._campo_visibile()[i][j];
			if (currentBlockValue < 0) continue;

			// Scenario 1: too many mines
			if (partita.conta_bandiere_vicine(i, j) > currentBlockValue) return;

			// Total bordering blocks	// TO DO: sostituire con una funzione di quelle mie
			int countBorderingBlocks;
			if ((i == 0 && j == 0) || (i == partita._larghezza() - 1 && i == partita._altezza() - 1)) countBorderingBlocks = 3;
			else if (i == 0 || j == 0 || j == partita._larghezza() - 1 || j == partita._altezza() - 1) countBorderingBlocks = 5;
			else countBorderingBlocks = 8;

			// Scenario 2: too many empty
			if (countBorderingBlocks - partita.conta_bandiere_vicine(i, j) < currentBlockValue) return;
		}
	}

		std::cout << "Sono qua:" << std::endl;


		// We have too many flags
		if (partita._numero_bandiere() > partita._mine()) return;

		// Solution found!
		if (k == bordo.size()) {

			// We don't have the exact mine count, so no
			if (partita._numero_bandiere() < partita._mine()) return;

			std::vector<bool> solution (bordo.size());
			Matrice<bool> disposizione(partita._altezza(), partita._larghezza());
			for (int i = 0; i < bordo.size(); i++) {
				Coord block = bordo[i];
				partita.gioca(block.first, block.second, 'B');
				//disposizione[block.first][block.second] = true;
			}
			disposizioni.push_back(disposizione);
			return;
		}

		Coord block = bordo[k];

		// Recurse two positions: mine and no mine
		partita.gioca(block.first, block.second, 'B');
		metodo_probabilistico_ricorsivo(disposizioni, bordo, k + 1);
		partita.gioca(block.first, block.second, 'S');

		partita.gioca(block.first, block.second, 'S');
		metodo_probabilistico_ricorsivo(disposizioni, bordo, k + 1);
		partita.gioca(block.first, block.second, 'B');
}
*/

bool compara(std::pair<Coord, std::pair<double, double>> p, std::pair<Coord, std::pair<double, double>> q)
{
	return p.second.first < q.second.first;
}

/*
std::vector<std::vector<Coord> > Risolutore::separa_bordo()
{
	auto start = std::chrono::steady_clock::now();

	std::vector<Coord> incognite = estrai_celle_incognite();

	std::vector<std::vector<Coord> > incognite_separate;

	std::queue<Coord> coda;
	coda.push(incognite[0]);

	while (incognite.size() != 0)
	{
		for (int a = 1; a < 9; a++)
		{
			std::vector<Coord> incognite_separate_regione;
			
			if (incognite.size() != 0 && coda.size() == 0)
			{
				coda.push(incognite[0]);
			}

			while (incognite.size() != 0 && coda.size() != 0)
			{
				Coord cella = coda.front();
				coda.pop();

				if (partita._campo_visibile().indici_leciti(cella.first, cella.second) && !trova_elemento(incognite_separate_regione, cella) && trova_elemento(incognite, cella) && partita.conta_numeri_vicini(cella.first, cella.second) == a) //  
				{	
					std::cout << "(" << cella.first + 1 << ", " << cella.second + 1 << ") ";

					incognite_separate_regione.push_back(cella);
					incognite.erase(incognite.begin() + trova_indice_elemento(incognite, cella));

					//coda.push(Coord(cella.first - 1, cella.second - 1));
					coda.push(Coord(cella.first - 1, cella.second));
					//coda.push(Coord(cella.first - 1, cella.second + 1));
					coda.push(Coord(cella.first, cella.second - 1));
					coda.push(Coord(cella.first, cella.second + 1));
					//coda.push(Coord(cella.first + 1, cella.second - 1));
					coda.push(Coord(cella.first + 1, cella.second));
					//coda.push(Coord(cella.first + 1, cella.second + 1));

				}
			}

			if (incognite_separate_regione.size() != 0)
			{
				incognite_separate.push_back(incognite_separate_regione);
			}
			
		}
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

	return incognite_separate;
}

std::vector<std::vector<Coord> > Risolutore::separa_bordo2()
{
	auto start = std::chrono::steady_clock::now();
	
	std::vector<Coord> incognite = estrai_celle_incognite();

	std::vector<std::vector<Coord> > incognite_separate;

	std::queue<Coord> coda;
	coda.push(incognite[0]);

	while (incognite.size() != 0)
	{
		std::vector<Coord> incognite_separate_regione;
		
		if (coda.size() == 0)
		{
			coda.push(incognite[0]);
		}

		while (coda.size() != 0)
		{
			Coord cella = coda.front();
			coda.pop();

			if (partita._campo_visibile().indici_leciti(cella.first, cella.second) && !trova_elemento(incognite_separate_regione, cella) && trova_elemento(incognite, cella) && partita.conta_se_numeri_vicini(cella.first, cella.second))
			{
				incognite_separate_regione.push_back(cella);
				incognite.erase(incognite.begin() + trova_indice_elemento(incognite, cella));

				//coda.push(Coord(cella.first - 1, cella.second - 1));
				coda.push(Coord(cella.first - 1, cella.second));
				//coda.push(Coord(cella.first - 1, cella.second + 1));
				coda.push(Coord(cella.first, cella.second - 1));
				coda.push(Coord(cella.first, cella.second + 1));
				//coda.push(Coord(cella.first + 1, cella.second - 1));
				coda.push(Coord(cella.first + 1, cella.second));
				//coda.push(Coord(cella.first + 1, cella.second + 1));

			}
		}

		incognite_separate.push_back(incognite_separate_regione);
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

	return incognite_separate;
}

std::vector<std::vector<Coord> > Risolutore::separa_numeri()
{
	auto start = std::chrono::steady_clock::now();

	std::vector<Coord> numeri = estrai_numeri_bordo();

	std::vector<std::vector<Coord> > numeri_separati;

	std::vector<std::vector<Coord> > incognite_separate = separa_bordo2();

	for (int i = 0; i < incognite_separate.size(); i++)
	{
		std::set<Coord> numeri_sezione;

		for (int j = 0; j < incognite_separate[i].size(); j++)
		{
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second - 1)))	numeri_sezione.insert(Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second - 1));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second)))		numeri_sezione.insert(Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second + 1)))	numeri_sezione.insert(Coord(incognite_separate[i][j].first - 1, incognite_separate[i][j].second + 1));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first, incognite_separate[i][j].second - 1)))		numeri_sezione.insert(Coord(incognite_separate[i][j].first, incognite_separate[i][j].second - 1));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first, incognite_separate[i][j].second + 1)))		numeri_sezione.insert(Coord(incognite_separate[i][j].first, incognite_separate[i][j].second + 1));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second - 1)))	numeri_sezione.insert(Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second - 1));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second)))		numeri_sezione.insert(Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second));
			if (trova_elemento(numeri, Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second + 1)))	numeri_sezione.insert(Coord(incognite_separate[i][j].first + 1, incognite_separate[i][j].second + 1));
		}

		std::vector<Coord> numeri_sezione_vettore (numeri_sezione.begin(), numeri_sezione.end());

		numeri_separati.push_back(numeri_sezione_vettore);
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

	return numeri_separati;
}

bool Risolutore::disposizione_lecita(std::vector<bool> disposizione_booleana, std::vector<Coord> incognite, std::vector<Coord> numeri)
{
	Campo test_posizione = partita;
	
	for (int i = 0; i < disposizione_booleana.size(); i++)
	{
		if (disposizione_booleana[i])
		{
			test_posizione.gioca(incognite[i].first, incognite[i].second, 'B');
		}
	}

	for (int i = 0; i < numeri.size(); i++)
	{
		if (test_posizione.conta_bandiere_vicine(numeri[i].first, numeri[i].second) > test_posizione._campo_visibile()[numeri[i].first][numeri[i].second]) return false;
	}

	return true;
}
*/
/*
void Risolutore::metodo_probabilistico()
{	
	auto start = std::chrono::steady_clock::now();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::vector<Coord> > incognite_separate = separa_bordo2();

	for (int i = 0; i < incognite_separate.size(); i++)
	{
		for (int j = 0; j < incognite_separate[i].size(); j++)
		{
			std::cout << "(" << incognite_separate[i][j].first + 1 << ", " << incognite_separate[i][j].second + 1<< ") ";
		}
		std::cout << std::endl;
	}

	system("PAUSE");

	
	// FASE 1: generare tutte le possibili disposizioni delle mine sezione per sezione

	std::vector<std::vector<std::vector<bool> > > possibili_disposizioni_separate;

	for (int k = 0; k < incognite_separate.size(); k++)
	{
		std::vector<bool> singola_disposizione (incognite_separate[k].size());
		std::set<std::vector<bool> > possibili_disposizioni;

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[k]);
		estremi.push_back(static_cast<int>(singola_disposizione.size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());

		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << mine_max_separate[k] << std::endl;
		std::cout << "singola_disposizione.size(): " << singola_disposizione.size() << std::endl;
		std::cout << "mine_rimanenti: " << partita._mine() - partita._numero_bandiere() << std::endl;

		
		for (int i = 0; i < estremo; i++)
		{
			singola_disposizione[i] = true;

			std::sort(singola_disposizione.begin(), singola_disposizione.end());

			do
			{
				if (disposizione_lecita(singola_disposizione, incognite_separate[k], numeri_separati[k]))
				{
					possibili_disposizioni.insert(singola_disposizione); // if (disposizione_lecita(singola_disposizione, incognite_separate[k])) 

						//for (int j = 0; j < singola_disposizione.size(); j++)
						//{
						//	std::cout << singola_disposizione[j];
						//}
					//std::cout << std::endl;
				}

			} while (std::next_permutation(singola_disposizione.begin(), singola_disposizione.end()));
		}

		possibili_disposizioni_separate.push_back(std::vector< std::vector<bool> > (possibili_disposizioni.cbegin(), possibili_disposizioni.cend() ));

	}

	std::cout << "STAMPO ROBA ORA: " << std::endl;

	for (int i = 0; i < possibili_disposizioni_separate.size(); i++)
	{
		for (int j = 0; j < possibili_disposizioni_separate[i].size(); j++)
		{
			for (int k = 0; k < possibili_disposizioni_separate[i][j].size(); k++)
			{
				std::cout << possibili_disposizioni_separate[i][j][k];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl << std::endl;
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/

	
	/*
		for (int i = 0; i < (*it).second.size(); i++)
		{
			disposizione.insert((*it).second[i].begin(), (*it).second[i].end());
			
			trova_soluzioni(possibilita_per_numero, disposizione, insieme_soluzioni, it++);

		}
		it++;
	}
	*/
	/*
	std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();
	
	std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();

	std::vector<Coord> numeri = estrai_numeri_bordo();

	std::vector<bool> numeri_usati(numeri.size());

	std::vector<bool> sezioni_usate (bordo.size());

	int numeri_usati_conteggio = 0;

	while (numeri_usati_conteggio < numeri.size())
	{

		// FASE 1: prendere gli indizi partendo dall'indizio che ha meno sezioni del bordo ad esso associato

		int bestClueBoundary = bordo.size() + 1;

		for (int i = 0; i < numeri.size(); i++)
		{
			if (!numeri_usati[i])
			{

				numeri_usati[i] = true;

				// un bordo_studio (TO DO: cambia nome) è una sezione del bordo i cui indizi sono stati usati (cioè controllati) solo in parte

				std::set<std::pair<std::vector<Coord>, std::vector<Coord> >> sezione_sotto_esame_insieme;

				for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
				{
					bool ha_numeri_usati = false;
					bool ha_numeri_non_usati = false;

					for (int j = 0; j < (*it).first.size(); j++)
					{
						if (!numeri_usati[trova_indice_elemento(numeri, (*it).first[j])])
						{
							ha_numeri_non_usati = true;
						}
						else
						{
							ha_numeri_usati = true;
						}
						if (ha_numeri_non_usati && ha_numeri_usati) sezione_sotto_esame_insieme.insert((*it));
					}

				}

				std::vector< std::pair<std::vector<Coord>, std::vector<Coord>> > sezione_sotto_esame(sezione_sotto_esame_insieme.begin(), sezione_sotto_esame_insieme.end());

				std::cout << "RAGGRUPPAMENTI" << std::endl;

				for (int k = 0; k < sezione_sotto_esame.size(); k++)
				{
					std::cout << "NUMERI ADIACENTI" << std::endl;

					for (int v = 0; v < sezione_sotto_esame[k].first.size(); v++)
					{
						std::cout << "(" << sezione_sotto_esame[k].first[v].first + 1 << ", " << sezione_sotto_esame[k].first[v].second + 1 << ") ";
					}
					std::cout << "COORDINATE" << std::endl;

					for (int v = 0; v < sezione_sotto_esame[k].second.size(); v++)
					{
						std::cout << "(" << sezione_sotto_esame[k].second[v].first + 1 << ", " << sezione_sotto_esame[k].second[v].second + 1 << ") ";

					}
					std::cout << std::endl;

				}
				
				std::vector<bool> super_sezione_sotto_esame;

				int clueLists = {}; // list of clues (as string) => list of groupings
				for (int b = 0; b < sezione_sotto_esame.size(); b++) {
					
					
					std::vector<Coord> bb = bordo[sezione_sotto_esame[b]];
					boundaryClues = bb[1];
					var boundaryClueString = "";
					for (var bc = 0; bc < boundaryClues.length; bc++) {
						bbc = boundaryClues[bc];
						if (usedClues[bbc] == 0) {
							boundaryClueString += bbc + ",";
						}
					}
					if (boundaryClueString in clueLists) {
						clueLists[boundaryClueString].push(boundary[b]);
					}
					else {
						clueLists[boundaryClueString] = [boundary[b]];
					}
				}
				var boundaryGroups = [];
				for (key in clueLists) {
					boundaryGroups.push(clueLists[key]);
				}
				return boundaryGroups;


				var newSupergroups = getBoundarySupergroups(groupings, cluesUsed, newBoundary);
				cluesUsed[tryClue] = 0;
				var boundaryChange = newSupergroups.length;
				
			}
		}


		numeri_usati_conteggio++;
	}
	*/

	

/*
void Risolutore::trova_soluzioni(std::vector<std::vector<std::map<Coord, bool>>>& possibilita_per_numero, std::vector<std::map<Coord, bool>>& disposizione, std::vector<std::vector<std::map<Coord, bool>>>::iterator it, std::vector<std::vector<std::map<Coord, bool>>>::iterator fine)
{
	if (it == fine)
	{
		possibilita_per_numero.push_back(disposizione);
		return;
	}

	std::vector<std::map<Coord, bool>> itdisp = *it;
	for (std::vector<std::map<Coord, bool>>::iterator jt = itdisp.begin(); jt != itdisp.end(); jt++)
	{
		disposizione.push_back(*jt);
		trova_soluzioni(possibilita_per_numero, disposizione, it++, fine);
		disposizione.pop_back();
	}

}
*/


/*
std::vector<std::map<Coord, std::vector<Coord>>> Risolutore::incognite_per_numero()
{
	std::vector<Coord> numeri = estrai_numeri_bordo();

	
	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<std::map<Coord, std::vector<Coord>>> incognite_per_numero_per_sezione;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		std::map< Coord, std::vector<Coord>> incognite_per_numero;

		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::vector<Coord> incognite_accanto;

			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first - 1, numeri_separati[i][j].second - 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first - 1, bordo_separato[i][j].second - 1));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first - 1, numeri_separati[i][j].second)))		incognite_accanto.push_back(Coord(bordo_separato[i][j].first - 1, bordo_separato[i][j].second));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first - 1, numeri_separati[i][j].second + 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first - 1, bordo_separato[i][j].second + 1));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first,	 numeri_separati[i][j].second - 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first, bordo_separato[i][j].second - 1));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first,	 numeri_separati[i][j].second + 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first, bordo_separato[i][j].second + 1));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first + 1, numeri_separati[i][j].second - 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first + 1, bordo_separato[i][j].second - 1));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first + 1, numeri_separati[i][j].second)))		incognite_accanto.push_back(Coord(bordo_separato[i][j].first + 1, bordo_separato[i][j].second));
			if (trova_elemento(bordo_separato[i], Coord(numeri_separati[i][j].first + 1, numeri_separati[i][j].second + 1)))	incognite_accanto.push_back(Coord(bordo_separato[i][j].first + 1, bordo_separato[i][j].second + 1));

			incognite_per_numero[numeri_separati[i][j]] = incognite_accanto;
		}

		incognite_per_numero_per_sezione.push_back(incognite_per_numero);
	}

	return incognite_per_numero_per_sezione;
}
*/


/*
struct Iterators {
	std::vector<std::map<Coord, bool>>::const_iterator begin;
	std::vector<std::map<Coord, bool>>::const_iterator end;
	std::vector<std::map<Coord, bool>>::const_iterator me;
};
typedef std::vector<Iterators> Vi;

void Risolutore::trova_soluzioni(std::vector<std::vector<std::map<Coord, bool>>>& tutte_disposizioni, std::vector<std::vector<std::map<Coord, bool>>>& possibilita_per_numero)
{
	Vi vi;

	// Start all of the iterators at the beginning.
	for (std::vector<std::vector<std::map<Coord, bool>>>::const_iterator it = possibilita_per_numero.cbegin(); it != possibilita_per_numero.cend(); it++)
	{
		Iterators d = { (*it).begin(), (*it).end(), (*it).begin() };
		vi.push_back(d);
	}

	while (true)
	{

		// Construct your first product vector by pulling 
		// out the element of each vector via the iterator.
		std::vector<std::map<Coord, bool>> result;
		for (Vi::const_iterator it = vi.begin(); it != vi.end(); it++)
		{
			result.push_back(*(it->me));
		}
		tutte_disposizioni.push_back(result);

		// Increment the rightmost one, and repeat.

		// When you reach the end, reset that one to the beginning and
		// increment the next-to-last one. You can get the "next-to-last"
		// iterator by pulling it out of the neighboring element in your
		// vector of iterators.
		for (Vi::iterator it = vi.begin(); ; )
		{
			// okay, I started at the left instead. sue me
			(it->me)++;
			if (it->me == it->end)
			{
				if (it + 1 == vi.end())
				{
					// I'm the last digit, and I'm about to roll
					return;
				}
				else
				{
					// cascade
					it->me = it->begin;
					++it;
				}
			}
			else
			{
				// normal
				break;
			}
		}
	}
}
*/


/*
	std::cout << "BORDO SEPARATO" << std::endl;

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	for (int i = 0; i < bordo_separato.size(); i++)
	{
		for (int j = 0; j < bordo_separato[i].size(); j++)
		{
			std::cout << "(" << bordo_separato[i][j].first + 1 << ", " << bordo_separato[i][j].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl << "numeri separati" << std::endl;

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();

	for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
	{
		std::cout << "GRUPPO " << std::endl << std::endl;

		std::cout << "NUMERI ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).first.size(); i++)
		{
			std::cout << "(" << (*it).first[i].first + 1 << ", " << (*it).first[i].second + 1 << ") ";
		}

		std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).second.size(); i++)
		{
			std::cout << "(" << (*it).second[i].first + 1 << ", " << (*it).second[i].second + 1 << ") ";
		}
		std::cout << std::endl;
	}
	*/


	/*
		for (std::map<Coord, std::vector<std::map<Coord, bool>>>::iterator it = possibilita_per_numero.begin(); it != possibilita_per_numero.end(); it++)
		{
			std::cout << "NUMERO: (" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ")" << std::endl << std::endl;

			std::cout << "DISPOSIZIONI: " << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				for (std::map<Coord, bool>::iterator jt = (*it).second[i].begin(); jt != (*it).second[i].end(); jt++)
				{
					std::cout << "(" << (*jt).first.first + 1 << ", " << (*jt).first.second + 1 << "): " << (*jt).second << std::endl;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		*/

		/*std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();

		for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
		{
			std::cout << "GRUPPO " << std::endl << std::endl;

			std::cout << "NUMERI ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).first.size(); i++)
			{
				std::cout << "(" << (*it).first[i].first + 1 << ", " << (*it).first[i].second + 1 << ") ";
			}

			std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				std::cout << "(" << (*it).second[i].first + 1<< ", " << (*it).second[i].second + 1 << ") ";
			}
			std::cout << std::endl;
		}

		std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();

		for (std::map<Coord, std::vector<Coord> >::iterator it = incognite_per_numeri.begin(); it != incognite_per_numeri.end(); it++)
		{
			std::cout << "GRUPPO " << std::endl << std::endl;

			std::cout << "NUMERO" << std::endl;
			std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ") ";

			std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				std::cout << "(" << (*it).second[i].first + 1 << ", " << (*it).second[i].second + 1 << ") ";
			}
			std::cout << std::endl;
		}*/

		// std::vector <std::map<Coord, bool>> disposizione;

		//std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore = trova_soluzioni(possibilita_per_numero_vettore);
		//std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore;
		//trova_soluzioni(tutte_possibilita_vettore, possibilita_per_numero_vettore);

		//trova_soluzioni(tutte_possibilita_vettore, disposizione, possibilita_per_numero_vettore.begin(), possibilita_per_numero_vettore.end());


/*
void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	std::cout << "BORDO SEPARATO" << std::endl;

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	for (int i = 0; i < bordo_separato.size(); i++)
	{
		for (int j = 0; j < bordo_separato[i].size(); j++)
		{
			std::cout << "(" << bordo_separato[i][j].first + 1 << ", " << bordo_separato[i][j].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl << "numeri separati" << std::endl;

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
		}
		std::cout << std::endl;
	}
	
	std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();

	for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
	{
		std::cout << "GRUPPO " << std::endl << std::endl;

		std::cout << "NUMERI ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).first.size(); i++)
		{
			std::cout << "(" << (*it).first[i].first + 1 << ", " << (*it).first[i].second + 1 << ") ";
		}

		std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).second.size(); i++)
		{
			std::cout << "(" << (*it).second[i].first + 1 << ", " << (*it).second[i].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::vector<std::map<Coord, std::vector<Coord>>> incognite_per_numeri_per_sezione = incognite_per_numero_per_bordo();
	
	for (int a = 0; a < incognite_per_numeri_per_sezione.size(); a++)
	{

	std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numeri_per_sezione[a];
		
		std::map<Coord, std::vector<std::map<Coord, bool>>> possibilita_per_numero;
		
		for (std::map<Coord, std::vector<Coord>>::const_iterator it = incognite_per_numeri.cbegin(); it != incognite_per_numeri.cend(); it++)
		{
			std::set<std::map<Coord, bool>> disposizioni_per_numero;

			std::vector<bool> disposizione(it->second.size());

			std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ") " << std::endl;

			for (int i = 0; i < partita._campo_visibile()[(*it).first.first][(*it).first.second] - partita.conta_bandiere_vicine((*it).first.first, (*it).first.second); i++)
			{
				disposizione[i] = true;

				std::sort(disposizione.begin(), disposizione.end());
				do
				{
					std::map<Coord, bool> disposizione_singolo_numero;

					for (int j = 0; j < disposizione.size(); j++)
					{
						std::cout << disposizione[j];
						if (disposizione[j]) disposizione_singolo_numero[(*it).second[j]] = true;
						else disposizione_singolo_numero[(*it).second[j]] = false;
					}

					disposizioni_per_numero.insert(disposizione_singolo_numero);
					std::cout << std::endl;
				} while (std::next_permutation(disposizione.begin(), disposizione.end()));
			}

			std::vector<std::map<Coord, bool>> disposizioni_per_numero_vettore(disposizioni_per_numero.begin(), disposizioni_per_numero.end());

			possibilita_per_numero[(*it).first] = disposizioni_per_numero_vettore;
		}

		
		for (std::map<Coord, std::vector<std::map<Coord, bool>>>::iterator it = possibilita_per_numero.begin(); it != possibilita_per_numero.end(); it++)
		{
			std::cout << "NUMERO: (" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ")" << std::endl << std::endl;

			std::cout << "DISPOSIZIONI: " << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				for (std::map<Coord, bool>::iterator jt = (*it).second[i].begin(); jt != (*it).second[i].end(); jt++)
				{
					std::cout << "(" << (*jt).first.first + 1 << ", " << (*jt).first.second + 1 << "): " << (*jt).second << std::endl;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		

		std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();

		for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
		{
			std::cout << "GRUPPO " << std::endl << std::endl;

			std::cout << "NUMERI ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).first.size(); i++)
			{
				std::cout << "(" << (*it).first[i].first + 1 << ", " << (*it).first[i].second + 1 << ") ";
			}

			std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				std::cout << "(" << (*it).second[i].first + 1<< ", " << (*it).second[i].second + 1 << ") ";
			}
			std::cout << std::endl;
		}

		std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();

		for (std::map<Coord, std::vector<Coord> >::iterator it = incognite_per_numeri.begin(); it != incognite_per_numeri.end(); it++)
		{
			std::cout << "GRUPPO " << std::endl << std::endl;

			std::cout << "NUMERO" << std::endl;
			std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ") ";

			std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
			for (int i = 0; i < (*it).second.size(); i++)
			{
				std::cout << "(" << (*it).second[i].first + 1 << ", " << (*it).second[i].second + 1 << ") ";
			}
			std::cout << std::endl;
		}

		std::vector<std::vector<std::map<Coord, bool>>> possibilita_per_numero_vettore;
		for (std::map<Coord, std::vector<std::map<Coord, bool>>>::iterator it = possibilita_per_numero.begin(); it != possibilita_per_numero.end(); it++)
		{
			possibilita_per_numero_vettore.push_back((*it).second);
		}

		std::vector <std::map<Coord, bool>> disposizione;

		std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore = trova_soluzioni(possibilita_per_numero_vettore);
		//std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore;
		//trova_soluzioni(tutte_possibilita_vettore, possibilita_per_numero_vettore);

		//trova_soluzioni(tutte_possibilita_vettore, disposizione, possibilita_per_numero_vettore.begin(), possibilita_per_numero_vettore.end());

		std::cout << "DISPOSIZIONI: " << tutte_possibilita_vettore.size() << std::endl;

		for (int i = 0; i < tutte_possibilita_vettore.size(); i++)
		{
			for (int j = 0; j < tutte_possibilita_vettore[i].size(); j++)
			{
				for (std::map<Coord, bool>::iterator it = tutte_possibilita_vettore[i][j].begin(); it != tutte_possibilita_vettore[i][j].end(); it++)
				{
					std::cout << (*it).second;
					//std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << "): " << (*it).second << std::endl;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
	 }

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/
/*
Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();

	std::vector<Coord> incognite = estrai_celle_incognite();

	std::map<Coord, std::vector<std::map<Coord, bool>>> possibilita_per_numero;

	for (std::map<Coord, std::vector<Coord>>::const_iterator it = incognite_per_numeri.cbegin(); it != incognite_per_numeri.cend(); it++)
	{
		std::set<std::map<Coord, bool>> disposizioni_per_numero;

		std::vector<bool> disposizione(it->second.size());

		std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ") " << std::endl;

		for (int i = 0; i < partita._campo_visibile()[(*it).first.first][(*it).first.second] - partita.conta_bandiere_vicine((*it).first.first, (*it).first.second); i++)
		{
			disposizione[i] = true;

			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				std::map<Coord, bool> disposizione_singolo_numero;

				for (int j = 0; j < disposizione.size(); j++)
				{
					std::cout << disposizione[j];
					if (disposizione[j]) disposizione_singolo_numero[(*it).second[j]] = true;
					else disposizione_singolo_numero[(*it).second[j]] = false;
				}

				disposizioni_per_numero.insert(disposizione_singolo_numero);
				std::cout << std::endl;
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}

		std::vector<std::map<Coord, bool>> disposizioni_per_numero_vettore(disposizioni_per_numero.begin(), disposizioni_per_numero.end());

		possibilita_per_numero[(*it).first] = disposizioni_per_numero_vettore;
	}

	/*
	for (std::map<Coord, std::vector<std::map<Coord, bool>>>::iterator it = possibilita_per_numero.begin(); it != possibilita_per_numero.end(); it++)
	{
		std::cout << "NUMERO: (" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ")" << std::endl << std::endl;

		std::cout << "DISPOSIZIONI: " << std::endl;
		for (int i = 0; i < (*it).second.size(); i++)
		{
			for (std::map<Coord, bool>::iterator jt = (*it).second[i].begin(); jt != (*it).second[i].end(); jt++)
			{
				std::cout << "(" << (*jt).first.first + 1 << ", " << (*jt).first.second + 1 << "): " << (*jt).second << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
	*/

	/*std::map<std::vector<Coord>, std::vector<Coord>> bordo = separa_bordo();

	for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo.begin(); it != bordo.end(); it++)
	{
		std::cout << "GRUPPO " << std::endl << std::endl;

		std::cout << "NUMERI ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).first.size(); i++)
		{
			std::cout << "(" << (*it).first[i].first + 1 << ", " << (*it).first[i].second + 1 << ") ";
		}

		std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).second.size(); i++)
		{
			std::cout << "(" << (*it).second[i].first + 1<< ", " << (*it).second[i].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();

	for (std::map<Coord, std::vector<Coord> >::iterator it = incognite_per_numeri.begin(); it != incognite_per_numeri.end(); it++)
	{
		std::cout << "GRUPPO " << std::endl << std::endl;

		std::cout << "NUMERO" << std::endl;
		std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << ") ";

		std::cout << std::endl << "COORDINATE INCOGNITE ADIACENTI" << std::endl;
		for (int i = 0; i < (*it).second.size(); i++)
		{
			std::cout << "(" << (*it).second[i].first + 1 << ", " << (*it).second[i].second + 1 << ") ";
		}
		std::cout << std::endl;
	}

	std::vector<std::vector<std::map<Coord, bool>>> possibilita_per_numero_vettore;
	for (std::map<Coord, std::vector<std::map<Coord, bool>>>::iterator it = possibilita_per_numero.begin(); it != possibilita_per_numero.end(); it++)
	{
		possibilita_per_numero_vettore.push_back((*it).second);
	}

	std::vector <std::map<Coord, bool>> disposizione;

	std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore = trova_soluzioni(possibilita_per_numero_vettore);
	//std::vector<std::vector<std::map<Coord, bool>>> tutte_possibilita_vettore;
	//trova_soluzioni(tutte_possibilita_vettore, possibilita_per_numero_vettore);

	//trova_soluzioni(tutte_possibilita_vettore, disposizione, possibilita_per_numero_vettore.begin(), possibilita_per_numero_vettore.end());

	std::cout << "DISPOSIZIONI: " << tutte_possibilita_vettore.size() << std::endl;

	for (int i = 0; i < tutte_possibilita_vettore.size(); i++)
	{
		for (int j = 0; j < tutte_possibilita_vettore[i].size(); j++)
		{
			for (std::map<Coord, bool>::iterator it = tutte_possibilita_vettore[i][j].begin(); it != tutte_possibilita_vettore[i][j].end(); it++)
			{
				std::cout << (*it).second;
				//std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << "): " << (*it).second << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/


/*
std::pair<std::vector<Coord>, std::vector<Coord> > Risolutore::estrai_numeri_bordo_celle_incognite()
{
	std::vector<Coord> numeri;

	std::set<Coord> incognite;
	
	// recuperiamo tutte i numeri che hanno ancora delle celle non scavate (e non bandierate) attorno: immagazziniamo tutto in un vettore

	for (int i = 0; i < partita._altezza(); i++)
	{
		for (int j = 0; j < partita._larghezza(); j++)
		{
			if (partita._campo_visibile()[i][j] > 0 && partita.conta_non_scavati_vicini(i, j) > 0)
			{
				numeri.push_back(Coord(i, j));

				if (partita._campo_visibile().indici_leciti(i - 1, j - 1)	&& partita._campo_visibile()[i - 1][j - 1] == -3)	incognite.insert(Coord(i - 1, j - 1));
				if (partita._campo_visibile().indici_leciti(i - 1, j)		&& partita._campo_visibile()[i - 1][j] == -3)		incognite.insert(Coord(i - 1, j));
				if (partita._campo_visibile().indici_leciti(i - 1, j + 1)	&& partita._campo_visibile()[i - 1][j + 1] == -3)	incognite.insert(Coord(i - 1, j + 1));
				if (partita._campo_visibile().indici_leciti(i, j - 1)		&& partita._campo_visibile()[i][j - 1] == -3)		incognite.insert(Coord(i, j - 1));
				if (partita._campo_visibile().indici_leciti(i, j + 1)		&& partita._campo_visibile()[i][j + 1] == -3)		incognite.insert(Coord(i, j + 1));
				if (partita._campo_visibile().indici_leciti(i + 1, j - 1)	&& partita._campo_visibile()[i + 1][j - 1] == -3)	incognite.insert(Coord(i + 1, j - 1));
				if (partita._campo_visibile().indici_leciti(i + 1, j)		&& partita._campo_visibile()[i + 1][j] == -3)		incognite.insert(Coord(i + 1, j));
				if (partita._campo_visibile().indici_leciti(i + 1, j + 1)	&& partita._campo_visibile()[i + 1][j + 1] == -3)	incognite.insert(Coord(i + 1, j + 1));

			}
		}
	}
	
	// convertiamo l'insieme in un vettore per applicare più facilmente il passaggio successivo

	std::vector<Coord> incognite_vettore(incognite.begin(), incognite.end());

	return std::pair<std::vector<Coord>, std::vector<Coord> >(numeri, incognite_vettore);
}
*/

	//std::vector<std::map<Coord, std::vector<Coord>>> incognite_per_numero_per_bordo();
	//std::vector<std::map<Coord, std::vector<Coord>>> incognite_per_numero();

	//void trova_soluzioni(std::vector<std::vector<std::map<Coord, bool>>>&, std::vector<std::map<Coord, bool>>&, std::vector<std::vector<std::map<Coord, bool>>>::iterator, std::vector<std::vector<std::map<Coord, bool>>>::iterator);
	//std::vector<std::vector<std::map<Coord, bool>>> trova_soluzioni(const std::vector<std::vector<std::map<Coord, bool>>>&);
	//void trova_soluzioni(std::vector<std::vector<std::map<Coord, bool>>>&, std::vector<std::vector<std::map<Coord, bool>>>&);

		//std::map< std::vector<Coord>, std::vector<Coord> > separa_bordo();

			//std::pair<std::vector<Coord>, std::vector<Coord> > estrai_numeri_bordo_celle_incognite();

				//void metodo_probabilistico_ricorsivo(Campo&, std::map<int, std::vector<std::vector<bool> > >&, std::vector<Coord>, int);

					std::map<Coord, std::vector<Coord>> incognite_per_numero();


					/*
void Risolutore::metodo_gaussiano()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1: creazione della matrice di incognite
	
	//std::pair<std::vector<Coord>, std::vector<Coord>> numeri_e_incognite = estrai_numeri_bordo_celle_incognite();

	std::vector<Coord> coordinate_numeri_bordo = estrai_numeri_bordo();
	std::vector<Coord> incognite_bordo = estrai_celle_incognite();

	std::vector<int> numeri_bordo;
	
	Matrice<int> matrice(static_cast<int>( coordinate_numeri_bordo.size() ), static_cast<int>( incognite_bordo.size() ));
	
	for (int n = 0; n < matrice._righe(); n++)
	{
		int i = coordinate_numeri_bordo[n].first;
		int j = coordinate_numeri_bordo[n].second;

		numeri_bordo.push_back(partita._campo_visibile()[i][j] - partita.conta_bandiere_vicine(i,j));
				
		if (trova_elemento(incognite_bordo, Coord (i - 1, j - 1)))	matrice[n][trova_indice_elemento(incognite_bordo, Coord (i - 1, j - 1))]	= 1;
		if (trova_elemento(incognite_bordo, Coord (i - 1, j)))		matrice[n][trova_indice_elemento(incognite_bordo, Coord (i - 1, j))]		= 1;
		if (trova_elemento(incognite_bordo, Coord (i - 1, j + 1)))	matrice[n][trova_indice_elemento(incognite_bordo, Coord (i - 1, j + 1))]	= 1;
		if (trova_elemento(incognite_bordo, Coord (i, j - 1)))		matrice[n][trova_indice_elemento(incognite_bordo, Coord (i, j - 1))]		= 1;
		if (trova_elemento(incognite_bordo, Coord (i, j + 1)))		matrice[n][trova_indice_elemento(incognite_bordo, Coord (i, j + 1))]			= 1;
		if (trova_elemento(incognite_bordo, Coord (i + 1, j - 1)))	matrice[n][trova_indice_elemento(incognite_bordo, Coord (i + 1, j - 1))]		= 1;
		if (trova_elemento(incognite_bordo, Coord (i + 1, j)))		matrice[n][trova_indice_elemento(incognite_bordo, Coord (i + 1, j))]			= 1;
		if (trova_elemento(incognite_bordo, Coord (i + 1, j + 1)))	matrice[n][trova_indice_elemento(incognite_bordo, Coord (i + 1, j + 1))]		= 1;
	}

	// FASE 2: riduzione gaussiana della matrice.

	matrice.riduzione_gaussiana(numeri_bordo);

	// FASE 3: sostituzione all'indietro e controllo delle soluzioni.

	//Consideriamo solamente le righe non vuote (il sistema originale non sempre ha soluzioni - anzi, quasi mai!)

	Matrice<int> matrice_ridotta(0, matrice._colonne());
	std::vector<int> termine_noto;
	std::vector<Coord> coordinate_numeri_bordo_ridotta;
	for (int i = 0; i < matrice._righe(); i++)
	{
		for (int j = 0; j < matrice._colonne(); j++)
		{
			if (matrice[i][j] != 0)
			{
				matrice_ridotta.push_back(matrice[i]);
				termine_noto.push_back(numeri_bordo[i]);
				coordinate_numeri_bordo_ridotta.push_back(coordinate_numeri_bordo[i]);
				break;
			}
		}
	}
	
	std::cout << matrice_ridotta << std::endl;

	for (int i = 0; i < termine_noto.size(); i++)
	{
		std::cout << termine_noto[i];
	}
	std::cout << std::endl;
	system("PAUSE");

	for (int i = matrice_ridotta._righe() - 1; i >= 0; i--)
	{
		int upper_bound = 0;
		int lower_bound = 0;

		for (int j = 0; j < matrice_ridotta._colonne(); j++)
		{
			if (matrice_ridotta[i][j] > 0)	upper_bound += matrice_ridotta[i][j];
			else lower_bound += matrice_ridotta[i][j];

		}

		if (upper_bound == termine_noto[i])
		{
			
			for (int j = 0; j < matrice_ridotta._colonne(); j++)
			{
				if (matrice_ridotta[i][j] > 0)
				{
					partita.gioca(incognite_bordo[j].first, incognite_bordo[j].second, 'B');
				}
				else if (matrice_ridotta[i][j] < 0)
				{
					partita.gioca(incognite_bordo[j].first, incognite_bordo[j].second, 'S');
				}
			}
		}
		else if (lower_bound == termine_noto[i])
		{
			// tutti i termini con coefficiente -1 sono mine, tutti quelli con coefficiente 1 non lo sono

			for (int j = 0; j < matrice_ridotta._colonne(); j++)
			{
				if (matrice_ridotta[i][j] < 0)
				{
					partita.gioca(incognite_bordo[j].first, incognite_bordo[j].second, 'B');
				}
				else if (matrice_ridotta[i][j] > 0)
				{
					partita.gioca(incognite_bordo[j].first, incognite_bordo[j].second, 'S');
				}
			}
		}
		if (i != 0)
		{
			for (int b = i - 1; b > 0; b--)
			{
				for (int a = 0; a < matrice_ridotta._colonne(); a++)
				{
					// TO DO: rendere l'operatore - parte di una specifica classe vettore che funge da base ad una classe matrix adattata - > campo deve diventare solo nel caso della classe Gioco (che potremmo rinominare Campo).
					matrice_ridotta[b][a] -= matrice_ridotta[i][a];
				}
				termine_noto[b] -= termine_noto[i];
			}
		}

	}
	
	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/

/*
std::vector<std::vector<Coord> > Risolutore::separa_bordo2()
{
	auto start = std::chrono::steady_clock::now();

	std::vector<Coord> incognite = estrai_celle_incognite();

	std::vector<std::vector<Coord> > incognite_separate;

	std::queue<Coord> coda;
	coda.push(incognite[0]);

	while (incognite.size() != 0)
	{
		std::vector<Coord> incognite_separate_regione;
		if (incognite.size() != 0 && coda.size() == 0)
		{
			coda.push(incognite[0]);
		}
		while (incognite.size() != 0 && coda.size() != 0)
		{
			Coord cella = coda.front();
			coda.pop();

			if (partita._campo_visibile().indici_leciti(cella.first, cella.second) && !trova_elemento(incognite_separate_regione, cella) && trova_elemento(incognite, cella)) //   && partita.conta_numeri_vicini(cella.first, cella.second) == a
			{
				incognite_separate_regione.push_back(cella);
				incognite.erase(incognite.begin() + trova_indice_elemento(incognite, cella));

				coda.push(Coord(cella.first - 1, cella.second));
				coda.push(Coord(cella.first, cella.second - 1));
				coda.push(Coord(cella.first, cella.second + 1));
				coda.push(Coord(cella.first + 1, cella.second));

			}
		}
		if (incognite_separate_regione.size() != 0)
		{
			//for (int i = 0; i < incognite_separate_regione.size(); i++)
			//{
			//	std::cout << "(" << incognite_separate_regione[i].first + 1 << ", " << incognite_separate_regione[i].second + 1 << ") ";
			//}

			incognite_separate.push_back(incognite_separate_regione);

			std::cout << std::endl;
		}	
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

	return incognite_separate;
}
*/
/*
std::map<std::vector<Coord>, std::vector<Coord>> Risolutore::separa_bordo()
{
	std::vector<Coord> incognite = estrai_celle_incognite();

	std::vector<Coord> numeri = estrai_numeri_bordo();

	std::map<std::vector<Coord>, std::vector<Coord>> bordo; // INCOGNITE SEPARATE, NUMERI ACCANTO

	for (int i = 0; i < incognite.size(); i++)
	{
		std::vector<Coord> numeri_accanto;

		if (trova_elemento(numeri, Coord(incognite[i].first - 1, incognite[i].second - 1)))	numeri_accanto.push_back(Coord(incognite[i].first - 1, incognite[i].second - 1));
		if (trova_elemento(numeri, Coord(incognite[i].first - 1, incognite[i].second)))		numeri_accanto.push_back(Coord(incognite[i].first - 1, incognite[i].second));
		if (trova_elemento(numeri, Coord(incognite[i].first - 1, incognite[i].second + 1)))	numeri_accanto.push_back(Coord(incognite[i].first - 1, incognite[i].second + 1));
		if (trova_elemento(numeri, Coord(incognite[i].first, incognite[i].second - 1)))		numeri_accanto.push_back(Coord(incognite[i].first, incognite[i].second - 1));
		if (trova_elemento(numeri, Coord(incognite[i].first, incognite[i].second + 1)))		numeri_accanto.push_back(Coord(incognite[i].first, incognite[i].second + 1));
		if (trova_elemento(numeri, Coord(incognite[i].first + 1, incognite[i].second - 1)))	numeri_accanto.push_back(Coord(incognite[i].first + 1, incognite[i].second - 1));
		if (trova_elemento(numeri, Coord(incognite[i].first + 1, incognite[i].second)))		numeri_accanto.push_back(Coord(incognite[i].first + 1, incognite[i].second));
		if (trova_elemento(numeri, Coord(incognite[i].first + 1, incognite[i].second + 1)))	numeri_accanto.push_back(Coord(incognite[i].first + 1, incognite[i].second + 1));
	
		if (numeri_accanto.size() == 0) continue;	// magari non è necessario

		bordo[numeri_accanto].push_back(incognite[i]);
	}
	return bordo;
}
*/


/*
std::map<Coord, std::vector<Coord>> Risolutore::incognite_per_numero()
{
	std::vector<Coord> numeri = estrai_numeri_bordo();
	
	std::map<std::vector<Coord>, std::vector<Coord>> bordo_separato = separa_bordo();

	std::map<Coord, std::vector<Coord>> incognite_per_numero;

	for (int i = 0; i < numeri.size(); i++)
	{
		std::set<Coord> sezione;

		for (std::map<std::vector<Coord>, std::vector<Coord> >::iterator it = bordo_separato.begin(); it != bordo_separato.end(); it++)
		{
			if (trova_elemento((*it).first, numeri[i]))
			{
				for (int j = 0; j < (*it).second.size(); j++)
				{
					sezione.insert((*it).second[j]);
				}
				 // inserisce le coordinate nel vettore sezione in fondo
			}
		}

		std::vector<Coord> sezione_vettore(sezione.begin(), sezione.end());

		incognite_per_numero[numeri[i]] = sezione_vettore;
	}

	return incognite_per_numero;
}
*/
/*
std::vector<std::map<Coord, std::vector<Coord>>> Risolutore::incognite_per_numero_per_bordo()
{
	std::map<Coord, std::vector<Coord>> incognite_per_numeri = incognite_per_numero();
	
	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	std::vector<std::map<Coord, std::vector<Coord>>> incognite_per_numero_per_bordo (bordo_separato.size());

	for (std::map<Coord, std::vector<Coord>>::iterator it = incognite_per_numeri.begin(); it != incognite_per_numeri.end(); it++)
	{
		for (int i = 0; i < bordo_separato.size(); i++)
		{
			for (int j = 0; j < (*it).second.size(); j++)
			{
				if (trova_elemento(bordo_separato[i], (*it).second[j])) (incognite_per_numero_per_bordo[i])[(*it).first] = (*it).second;
			}
		}
		
	}

	return incognite_per_numero_per_bordo;
}
*/
/*
std::vector<std::vector<std::map<Coord, bool>>> Risolutore::trova_soluzioni(const std::vector<std::vector<std::map<Coord, bool>>>& possibilita_per_numero)
{
	std::vector<std::vector<std::map<Coord, bool>>> res = { {} };
	for (const auto& u : possibilita_per_numero)
	{
		std::vector<std::vector<std::map<Coord, bool>>> temp;
		for (const auto& x : res)
		{
			for (const auto y : u)
			{
				temp.push_back(x);
				temp.back().push_back(y);
			}
		}
		res = std::move(temp);
	}
	return res;
}
*/
/*
bool compara(std::pair<Coord, std::pair<double, double>> p, std::pair<Coord, std::pair<double, double>> q)
{
	return p.second.first < q.second.first;
}
*/


/*
void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1 : Preparazione. Prendiamo il bordo di celle incognite (quelle accanto a dei numeri e il cui numero di bandiere non è sufficiente) e segmentiamo il  le celle in modo che siano

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			//std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>> possibilita_per_sezione;

	for (int a = 0; a < bordo_separato.size(); a++)
	{
		std::map<int, std::vector<std::vector<Boolcoord>>> disposizioni_per_sezione;

		std::vector<bool> disposizione(bordo_separato[a].size());

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[a]);
		estremi.push_back(static_cast<int>(bordo_separato[a].size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());

		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << estremi[0] << std::endl;
		std::cout << "singola_disposizione.size(): " << estremi[1] << std::endl;
		std::cout << "mine_rimanenti: " << estremi[2] << std::endl;

		for (int i = 0; i < estremo; i++)
		{
			disposizione[i] = true;
			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				if (disposizione_lecita(bordo_separato[a], numeri_separati[a], disposizione))
				{
					std::vector<Boolcoord> disposizione_con_coordinate;
					for (int j = 0; j < disposizione.size(); j++)
					{
						disposizione_con_coordinate.push_back(std::make_pair(bordo_separato[a][j], disposizione[j]));
					}
					disposizioni_per_sezione[somma_elementi(disposizione)].push_back(disposizione_con_coordinate);
				}
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}
		//std::vector<std::vector<Boolcoord>> disposizioni_per_sezione_vettore(disposizioni_per_sezione.begin(), disposizioni_per_sezione.end());

		possibilita_per_sezione.push_back(disposizioni_per_sezione);
	}

	std::cout << u8"N° SEZIONI: " << possibilita_per_sezione.size() << std::endl;		// std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>>

	for (int i = 0; i < possibilita_per_sezione.size(); i++)
	{
		std::cout << u8"SEZIONE N°: " << i + 1 << std::endl;

		for (std::map<int, std::vector<std::vector<Boolcoord>>>::iterator it = possibilita_per_sezione[i].begin(); it != possibilita_per_sezione[i].end(); it++)
		{
			std::cout << u8"N° MINE: " << (*it).first << std::endl;
			for (int j = 0; j < (*it).second.size(); j++)
			{
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << "(" << (*it).second[j][k].first.first + 1 << "," << (*it).second[j][k].first.second + 1 << ")";
				}
				std::cout << std::endl;
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << (*it).second[j][k].second;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}

void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1 : Preparazione. Prendiamo il bordo di celle incognite (quelle accanto a dei numeri e il cui numero di bandiere non è sufficiente) e segmentiamo il  le celle in modo che siano 

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			//std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>> possibilita_per_sezione;

	for (int a = 0; a < bordo_separato.size(); a++)
	{
		std::map<int, std::vector<std::vector<Boolcoord>>> disposizioni_per_sezione;

		std::vector<bool> disposizione(bordo_separato[a].size());

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[a]);
		estremi.push_back(static_cast<int>(bordo_separato[a].size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());

		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << estremi[0] << std::endl;
		std::cout << "singola_disposizione.size(): " << estremi[1] << std::endl;
		std::cout << "mine_rimanenti: " << estremi[2] << std::endl;

		for (int i = 0; i < estremo; i++)
		{
			disposizione[i] = true;
			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				if (disposizione_lecita(bordo_separato[a], numeri_separati[a], disposizione))
				{
					std::vector<Boolcoord> disposizione_con_coordinate;
					for (int j = 0; j < disposizione.size(); j++)
					{
						disposizione_con_coordinate.push_back(std::make_pair(bordo_separato[a][j], disposizione[j]));
					}
					disposizioni_per_sezione[somma_elementi(disposizione)].push_back(disposizione_con_coordinate);
				}
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}
		//std::vector<std::vector<Boolcoord>> disposizioni_per_sezione_vettore(disposizioni_per_sezione.begin(), disposizioni_per_sezione.end());

		possibilita_per_sezione.push_back(disposizioni_per_sezione);
	}

	std::cout << u8"N° SEZIONI: " << possibilita_per_sezione.size() << std::endl;		// std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>>

	for (int i = 0; i < possibilita_per_sezione.size(); i++)
	{		
		std::cout << u8"SEZIONE N°: " << i + 1 << std::endl;

		for (std::map<int, std::vector<std::vector<Boolcoord>>>::iterator it = possibilita_per_sezione[i].begin(); it != possibilita_per_sezione[i].end(); it++)
		{
			std::cout << u8"N° MINE: " << (*it).first << std::endl;
			for (int j = 0; j < (*it).second.size(); j++)
			{
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << "(" << (*it).second[j][k].first.first + 1 << "," << (*it).second[j][k].first.second + 1 << ")";
				}
				std::cout << std::endl;
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << (*it).second[j][k].second;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1 : Preparazione. Prendiamo il bordo di celle incognite (quelle accanto a dei numeri e il cui numero di bandiere non è sufficiente) e segmentiamo il  le celle in modo che siano 

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo2();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();
	
	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ") ";
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::vector<std::map<Coord, bool>>> possibilita_per_sezione;

	for (int a = 0; a < bordo_separato.size(); a++)
	{
		std::set<std::map<Coord, bool>> disposizioni_per_sezione;

		std::vector<bool> disposizione(bordo_separato[a].size());

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[a]);
		estremi.push_back(static_cast<int>(bordo_separato[a].size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());

		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << estremi[0] << std::endl;
		std::cout << "singola_disposizione.size(): " << estremi[1] << std::endl;
		std::cout << "mine_rimanenti: " << estremi[2] << std::endl;

		for (int i = 0; i < estremo; i++)
		{
			disposizione[i] = true;
			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				if (disposizione_lecita(bordo_separato[a], numeri_separati[a], disposizione))
				{
					std::map<Coord, bool> disposizione_singolo_numero;
					for (int j = 0; j < disposizione.size(); j++)
					{
						//std::cout << disposizione[j];
						disposizione_singolo_numero[bordo_separato[a][j]] = disposizione[j];
					}
					disposizioni_per_sezione.insert(disposizione_singolo_numero);
					//std::cout << std::endl;
				}
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}
		std::vector<std::map<Coord, bool>> disposizioni_per_sezione_vettore(disposizioni_per_sezione.begin(), disposizioni_per_sezione.end());

		possibilita_per_sezione.push_back(disposizioni_per_sezione_vettore);
	}
		
	std::cout << "N° SEZIONI: " << possibilita_per_sezione.size() << std::endl;

	for (int i = 0; i < possibilita_per_sezione.size(); i++)
	{
		std::cout << "N° DISPOSIZONI: " << possibilita_per_sezione[i].size() << std::endl;

		for (int j = 0; j < possibilita_per_sezione[i].size(); j++)
		{
			for (std::map<Coord, bool>::iterator it = possibilita_per_sezione[i][j].begin(); it != possibilita_per_sezione[i][j].end(); it++)
			{
				std::cout << (*it).second;
				//std::cout << "(" << (*it).first.first + 1 << ", " << (*it).first.second + 1 << "): " << (*it).second << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/

/*
typedef std::pair<Coord, bool> Boolcoord;

void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1 : Preparazione. Prendiamo il bordo di celle incognite (quelle accanto a dei numeri e il cui numero di bandiere non è sufficiente) e segmentiamo il  le celle in modo che siano 

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			std::cout << "(" << numeri_separati[i][j].first + 1 << ", " << numeri_separati[i][j].second + 1 << ")";
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>> possibilita_per_sezione;

	for (int a = 0; a < bordo_separato.size(); a++)
	{
		std::vector<Coord> sezione_numeri = numeri_separati[a];
		std::vector<Coord> sezione_bordo = bordo_separato[a];
		
		Matrice<int> matrice(static_cast<int>(sezione_numeri.size()), static_cast<int>(sezione_bordo.size()));
		std::vector<int> termine_noto;

		for (int n = 0; n < matrice._righe(); n++)
		{
			int i = sezione_numeri[n].first;
			int j = sezione_numeri[n].second;

			termine_noto.push_back(partita._campo_visibile()[i][j] - partita.conta_bandiere_vicine(i, j));

			if (trova_elemento(sezione_bordo, Coord(i - 1, j - 1)))	matrice[n][trova_indice_elemento(sezione_bordo, Coord(i - 1, j - 1))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i - 1, j)))		matrice[n][trova_indice_elemento(sezione_bordo, Coord(i - 1, j))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i - 1, j + 1)))	matrice[n][trova_indice_elemento(sezione_bordo, Coord(i - 1, j + 1))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i, j - 1)))		matrice[n][trova_indice_elemento(sezione_bordo, Coord(i, j - 1))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i, j + 1)))		matrice[n][trova_indice_elemento(sezione_bordo, Coord(i, j + 1))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i + 1, j - 1)))	matrice[n][trova_indice_elemento(sezione_bordo, Coord(i + 1, j - 1))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i + 1, j)))		matrice[n][trova_indice_elemento(sezione_bordo, Coord(i + 1, j))] = 1;
			if (trova_elemento(sezione_bordo, Coord(i + 1, j + 1)))	matrice[n][trova_indice_elemento(sezione_bordo, Coord(i + 1, j + 1))] = 1;
		}

		std::pair<Matrice<int>, std::vector<int>> matrice_completa = matrice.riduzione_gaussiana_con_termine_noto(termine_noto);
		
		std::vector<int> riga_vuota(matrice_completa.first._colonne(), 0);

		Matrice<int> matrice_ridotta(0, matrice_completa.first._colonne());
		std::vector<int> termine_noto_ridotto;
		for (int i = 0; i < matrice_completa.first._righe(); i++)
		{
			for (int j = 0; j < matrice_completa.first._colonne(); j++)
			{
				if (matrice_completa.first[i][j] != 0)
				{
					matrice_ridotta.push_back(matrice_completa.first[i]);
					termine_noto_ridotto.push_back(matrice_completa.second[i]);
					break;
				}
			}
		}
		
		std::cout << matrice_ridotta << std::endl;
		std::cout << converti_in_vettore_colonna(termine_noto_ridotto) << std::endl;

		std::map<int, std::vector<std::vector<Boolcoord>>> disposizioni_per_sezione;

		//std::vector<bool> disposizione(sezione_bordo.size());

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[a]);
		estremi.push_back(static_cast<int>(sezione_bordo.size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());
		//estremi.push_back(matrice._colonne() - matrice.rango());


		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << estremi[0] << std::endl;
		std::cout << "singola_disposizione.size(): " << estremi[1] << std::endl;
		std::cout << "mine_rimanenti: " << estremi[2] << std::endl;
		std::cout << "rango della matrice: " << matrice.rango() << std::endl;

		for (int i = 0; i < estremo; i++)
		{
			std::vector<bool> disposizione(sezione_bordo.size());
			
			for (int j = 0; j < i; j++)
			{
				disposizione[j] = true;
			}

			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				if (true) // disposizione_lecita(bordo_separato[a], numeri_separati[a], disposizione) //  && matrice.mul(converti_in_vettore_colonna(converti_to_int(disposizione))) == converti_in_vettore_colonna(termine_noto)
				{
					std::vector<Boolcoord> disposizione_con_coordinate;
					for (int j = 0; j < disposizione.size(); j++)
					{
						disposizione_con_coordinate.push_back(std::make_pair(bordo_separato[a][j], disposizione[j]));
					}
					disposizioni_per_sezione[somma_elementi(disposizione)].push_back(disposizione_con_coordinate);
				}
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}
		//std::vector<std::vector<Boolcoord>> disposizioni_per_sezione_vettore(disposizioni_per_sezione.begin(), disposizioni_per_sezione.end());

		possibilita_per_sezione.push_back(disposizioni_per_sezione);
	}
	
	std::cout << u8"N° SEZIONI: " << possibilita_per_sezione.size() << std::endl;		// std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>>

	for (int i = 0; i < possibilita_per_sezione.size(); i++)
	{
		std::cout << u8"SEZIONE N°: " << i + 1 << std::endl;

		for (std::map<int, std::vector<std::vector<Boolcoord>>>::iterator it = possibilita_per_sezione[i].begin(); it != possibilita_per_sezione[i].end(); it++)
		{
			std::cout << u8"N° MINE: " << (*it).first << std::endl;
			std::cout << u8"N° COMBINAZIONI: " << (*it).second.size() << std::endl;
				//for (int j = 0; j < (*it).second.size(); j++)
			//{
				//for (int k = 0; k < (*it).second[j].size(); k++)
				//{
					//std::cout << possibilita_per_sezione[i][j][k].second;
				//	std::cout << "(" << (*it).second[j][k].first.first + 1 << "," << (*it).second[j][k].first.second + 1 << ")";
				//}
				//std::cout << std::endl;
				//for (int k = 0; k < (*it).second[j].size(); k++)
				//{
				//	//std::cout << possibilita_per_sezione[i][j][k].second;
				//	std::cout << (*it).second[j][k].second;
				//}
				//std::cout << std::endl;
			//}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
	
	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/
/*
void Risolutore::metodo_probabilistico()
{
	auto start = std::chrono::steady_clock::now();

	// FASE 1 : Preparazione. Prendiamo il bordo di celle incognite (quelle accanto a dei numeri e il cui numero di bandiere non è sufficiente) e segmentiamo il  le celle in modo che siano 

	std::vector<std::vector<Coord> > bordo_separato = separa_bordo();

	std::vector<std::vector<Coord> > numeri_separati = separa_numeri();

	std::vector<int> mine_max_separate;

	for (int i = 0; i < numeri_separati.size(); i++)
	{
		int mine_max = 0;
		for (int j = 0; j < numeri_separati[i].size(); j++)
		{
			mine_max += partita._campo_visibile()[numeri_separati[i][j].first][numeri_separati[i][j].second] - partita.conta_bandiere_vicine(numeri_separati[i][j].first, numeri_separati[i][j].second);
		}
		std::cout << std::endl;
		mine_max_separate.push_back(mine_max);
	}

	std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>> possibilita_per_sezione;

	for (int a = 0; a < bordo_separato.size(); a++)
	{
		std::map<int, std::vector<std::vector<Boolcoord>>> disposizioni_per_sezione;

		std::vector<bool> disposizione(bordo_separato[a].size());

		std::vector<int> estremi;
		estremi.push_back(mine_max_separate[a]);
		estremi.push_back(static_cast<int>(bordo_separato[a].size()));
		estremi.push_back(partita._mine() - partita._numero_bandiere());

		int estremo = *std::min_element(estremi.begin(), estremi.end());

		std::cout << "estremo: " << estremo << std::endl;
		std::cout << "mine_max_separate: " << estremi[0] << std::endl;
		std::cout << "singola_disposizione.size(): " << estremi[1] << std::endl;
		std::cout << "mine_rimanenti: " << estremi[2] << std::endl;

		for (int i = 0; i < estremo; i++)
		{
			disposizione[i] = true;
			std::sort(disposizione.begin(), disposizione.end());
			do
			{
				if (disposizione_lecita(bordo_separato[a], numeri_separati[a], disposizione))
				{
					std::vector<Boolcoord> disposizione_con_coordinate;
					for (int j = 0; j < disposizione.size(); j++)
					{
						disposizione_con_coordinate.push_back(std::make_pair(bordo_separato[a][j], disposizione[j]));
					}
					disposizioni_per_sezione[somma_elementi(disposizione)].push_back(disposizione_con_coordinate);
				}
			} while (std::next_permutation(disposizione.begin(), disposizione.end()));
		}
		//std::vector<std::vector<Boolcoord>> disposizioni_per_sezione_vettore(disposizioni_per_sezione.begin(), disposizioni_per_sezione.end());

		possibilita_per_sezione.push_back(disposizioni_per_sezione);
	}

	std::cout << u8"N° SEZIONI: " << possibilita_per_sezione.size() << std::endl;		// std::vector<std::map<int, std::vector<std::vector<Boolcoord>>>>

	for (int i = 0; i < possibilita_per_sezione.size(); i++)
	{		
		std::cout << u8"SEZIONE N°: " << i + 1 << std::endl;

		for (std::map<int, std::vector<std::vector<Boolcoord>>>::iterator it = possibilita_per_sezione[i].begin(); it != possibilita_per_sezione[i].end(); it++)
		{
			std::cout << u8"N° MINE: " << (*it).first << std::endl;
			for (int j = 0; j < (*it).second.size(); j++)
			{
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << "(" << (*it).second[j][k].first.first + 1 << "," << (*it).second[j][k].first.second + 1 << ")";
				}
				std::cout << std::endl;
				for (int k = 0; k < (*it).second[j].size(); k++)
				{
					//std::cout << possibilita_per_sezione[i][j][k].second;
					std::cout << (*it).second[j][k].second;
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}

	auto end = std::chrono::steady_clock::now();

	auto diff = end - start;

	std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;

}
*/